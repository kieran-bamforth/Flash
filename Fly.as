/* Fly.as   Makes a movie clip move in a seemingly random way (like a fly) within boundaries.    I just wanted an excuse to play with trig, again.       - kieran bamforth 7/11/11 */   package  {		import flash.display.Sprite;	// I use movie clips here because you can attach dynamic properties to them	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.utils.Timer;		public class Fly extends Sprite {		// the actual fly (f)		private var f:MovieClip;		private var fColour:uint = 0xffffff;		private var fSize:uint = 4;		// the fly container (fc)		private var fc:MovieClip;				public function Fly() 		{			// create & initialise fc			fc = new MovieClip();						initMovieClip(fc, 10, 2);						addChild(fc);						// create & initialise f			f = new MovieClip();						with(f.graphics)			{				beginFill(fColour);				drawCircle(0, 0, fSize/2);				endFill();			}						// put the fly in fly container			fc.addChild(f);		}				/* This is very dirty, but it saves me typing alot of code. Basically, it sets dynamic properties to		   movie clips, which are then used later on in the code. 		   		   e = target movie clip,		   dR = destination Radius,		   dX = destination x,		   dY = destination y,		   vR = vector radians,		   vX = vector x,		   vY = vector y,		   s = speed. */		   		private function initMovieClip(e:MovieClip, dR:uint, s:uint)		{			e.dR = dR;			e.dX = 0;			e.dY = 0;			e.vR = 0;			e.vX = 0;			e.vY = 0;			e.s = s;			// get it to move!			e.addEventListener(Event.ENTER_FRAME, moveTowardsDestination);		}				private function moveTowardsDestination(e:Event)		{			/* Check the target movie clip has reached it's destination (dX + dY). 			   If it has, assign to it a new destination. If it hasn't, move it towards the destination */			var tM = e.target as MovieClip;			if (hasReachedDestination(tM))				calculateNewDestination(tM);			else			{				tM.vR = Math.atan2(tM.dY - tM.y, tM.dX - tM.x);				tM.vX = Math.cos(tM.vR) * tM.s;				tM.vY = Math.sin(tM.vR) * tM.s;				tM.x += tM.vX;				tM.y += tM.vY;			}			// leave a fly trail			var t:Sprite = new Sprite();			with(t.graphics)			{				beginFill(fColour);				drawCircle(0, 0, fSize);				endFill;			}			this.addChild(t);			t.addEventListener(Event.ENTER_FRAME, fadeOutTrail);		}				private function fadeOutTrail(e:Event)		{			this.removeChild(e.target as MovieClip);		}				private function hasReachedDestination(e:MovieClip):Boolean		{			return (numberIsNear(e.x, e.dX, e.s) &&					numberIsNear(e.y, e.dY, e.s)) ? true : false;		}				private function calculateNewDestination(e:MovieClip)		{			var randomRadians = toRadians(Math.random()*360);			var randomRadius = Math.random()*e.dR;			e.dX = Math.cos(randomRadians) * randomRadius;			e.dY = Math.sin(randomRadians) * randomRadius;		}				private function numberIsNear(number:Number, isNear:Number, range:Number):Boolean		{			var min:Number = isNear - range;			var max:Number = isNear + range;			return (number >= min && number <= max) ? true : false;		}				private function toRadians(degrees:int):int		{			return (degrees * Math.PI) / 180;		}			}	}